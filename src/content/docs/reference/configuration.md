---
title: Configuration Reference
description: Learn how the controller uses ingress resources, secrets, and Helm values to manage Cloudflare tunnels.
---

The controller relies on familiar Kubernetes primitives: an `IngressClass`, standard `Ingress` objects, and a credential secret that grants access to Cloudflare. Use this page to align your manifests and Helm values with the controllerâ€™s expectations.

## IngressClass: `cloudflare-tunnel`

| Field | Type | Description |
| ----- | ---- | ----------- |
| `ingressClass.name` | string | Name of the ingress class installed by the Helm chart (defaults to `cloudflare-tunnel`). |
| `ingressClass.controllerValue` | string | Controller signature reported to Kubernetes (`strrl.dev/cloudflare-tunnel-ingress-controller`). |
| `ingressClass.isDefaultClass` | bool | When `true`, marks the `cloudflare-tunnel` class as the cluster default (disabled by default). |

Assign `spec.ingressClassName: cloudflare-tunnel` (or the legacy annotation `kubernetes.io/ingress.class: cloudflare-tunnel`) to any `Ingress` you want the controller to manage.

## Credentials secret: `cloudflare-api`

The chart provisions a namespaced secret named `cloudflare-api` unless you point it at an existing secret. The controller reads:

| Field | Type | Description |
| ----- | ---- | ----------- |
| `api-token` | string | Cloudflare API token with `Account.Cloudflare Tunnel:Edit`, `Zone.DNS:Edit`, and `Zone.Zone:Read`. |
| `cloudflare-account-id` | string | Cloudflare account identifier that owns the tunnel. |
| `cloudflare-tunnel-name` | string | Name of the tunnel to create or reuse. |

To manage credentials outside of Helm, set:

```yaml
cloudflare:
  secretRef:
    name: cloudflare-external-secret
    accountIDKey: account_id
    tunnelNameKey: tunnel_name
    apiTokenKey: api_token
```

## Ingress routes

Controller behaviour is driven by the `Ingress` object that owns the route.

| Field / Annotation | Description |
| ------------------ | ----------- |
| `spec.rules[].host` | External hostname the controller configures in Cloudflare DNS. |
| `spec.rules[].http.paths[].backend.service.*` | Target Service name and port that `cloudflared` should proxy traffic to. |
| `cloudflare-tunnel-ingress-controller.strrl.dev/backend-protocol` | Override the upstream protocol (`http` by default, supports `https`). |
| `cloudflare-tunnel-ingress-controller.strrl.dev/proxy-ssl-verify` | Toggle TLS verification when proxying to HTTPS backends (`on`/`off`). |
| `cloudflare-tunnel-ingress-controller.strrl.dev/http-host-header` | Rewrite the HTTP Host header sent to the backend. |
| `cloudflare-tunnel-ingress-controller.strrl.dev/origin-server-name` | Customize the SNI hostname when proxying to TLS origins. |

## Helm values worth noting

- `cloudflared.extraArgs`: Append additional flags to the embedded `cloudflared` connectors (for example, `--post-quantum`).
- `cloudflaredServiceMonitor.create`: Enable a Prometheus ServiceMonitor when you already run kube-prometheus-stack.
- `replicaCount`: Scale the controller deployment; enable leader election for more than one replica.
- `resources`: Apply resource requests and limits to both the controller and the managed connectors.

These settings pair with standard Kubernetes RBAC objects generated by the chart, so you can run the controller in production without introducing any new CustomResourceDefinitions.

```yaml
metadata:
  labels:
    app.kubernetes.io/name: cloudflare-tunnel-ingress-controller
    app.kubernetes.io/managed-by: kustomize
```

These labels enable GitOps tools and cluster-wide policies to target your tunnel resources.
